/**
 * @file db/v1/database.proto
 * @description The definitive gRPC contract for the sqlite-server service.
 *
 * ARCHITECTURAL DESIGN:
 *
 * 1. DUAL TRANSACTION MODELS:
 *    - Streaming (Bidirectional): Best for short, interactive sessions where
 * the connection lifespan equals the transaction lifespan. Automatic rollback
 * on disconnect.
 *    - Unary (ID-Based): Best for stateless HTTP clients or long-running
 * workflows where holding a TCP connection open is brittle. Requires manual
 * 'Begin'/'Commit' and relies on server-side Timeouts (TTL) to clean up
 * "Zombie" transactions.
 *
 * 2. TYPE SAFETY (SPARSE HINTS):
 *    Since JSON/Protobuf lacks native support for some SQLite types (like BLOBs
 * or large Integers), we use a "Hint" system. The client sends data as standard
 * JSON types but provides a mapping (e.g., "param 0 is a BLOB") so the server
 * knows to decode Base64 before hitting the DB.
 *
 * 3. ERROR FIDELITY:
 *    We map native C SQLite result codes to a Proto Enum (`SqliteCode`). This
 * allows clients to programmatically react to specific errors (e.g., retrying
 * on SQLITE_BUSY) without parsing error string messages.
 */

syntax = "proto3";

package db.v1;

import "buf/validate/validate.proto";
// Standard types for dynamic values (JSON-like structure).
import "google/protobuf/struct.proto";
// Well Known Types for standardize time and empty messages
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";

option go_package = "sqlite-server/internal/protos/db/v1;dbv1";

// -----------------------------------------------------------------------------
// Enums
// -----------------------------------------------------------------------------

/**
 * SqliteCode maps standard SQLite C result codes to a Proto Enum.
 * Use this to handle specific DB errors programmatically.
 * Reference: https://www.sqlite.org/rescode.html
 */
enum SqliteCode {
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX
  // Successful result (0)
  SQLITE_CODE_OK = 0;
  // Generic error (1)
  SQLITE_CODE_ERROR = 1;
  // Internal logic error in SQLite (2)
  SQLITE_CODE_INTERNAL = 2;
  // Access permission denied (3)
  SQLITE_CODE_PERM = 3;
  // Callback routine requested an abort (4)
  SQLITE_CODE_ABORT = 4;
  // The database file is locked (5)
  SQLITE_CODE_BUSY = 5;
  // A table in the database is locked (6)
  SQLITE_CODE_LOCKED = 6;
  // A malloc() failed (7)
  SQLITE_CODE_NOMEM = 7;
  // Attempt to write a readonly database (8)
  SQLITE_CODE_READONLY = 8;
  // Operation terminated by sqlite3_interrupt() (9)
  SQLITE_CODE_INTERRUPT = 9;
  // Some kind of disk I/O error occurred (10)
  SQLITE_CODE_IOERR = 10;
  // The database disk image is malformed (11)
  SQLITE_CODE_CORRUPT = 11;
  // Unknown opcode in sqlite3_file_control() (12)
  SQLITE_CODE_NOTFOUND = 12;
  // Insertion failed because database is full (13)
  SQLITE_CODE_FULL = 13;
  // Unable to open the database file (14)
  SQLITE_CODE_CANTOPEN = 14;
  // Database lock protocol error (15)
  SQLITE_CODE_PROTOCOL = 15;
  // Internal use only (16)
  SQLITE_CODE_EMPTY = 16;
  // The database schema changed (17)
  SQLITE_CODE_SCHEMA = 17;
  // String or BLOB exceeds size limit (18)
  SQLITE_CODE_TOOBIG = 18;
  // Abort due to constraint violation (19)
  SQLITE_CODE_CONSTRAINT = 19;
  // Data type mismatch (20)
  SQLITE_CODE_MISMATCH = 20;
  // Library used incorrectly (21)
  SQLITE_CODE_MISUSE = 21;
  // Uses OS features not supported on host (22)
  SQLITE_CODE_NOLFS = 22;
  // Authorization denied (23)
  SQLITE_CODE_AUTH = 23;
  // Not used (24)
  SQLITE_CODE_FORMAT = 24;
  // 2nd parameter to sqlite3_bind out of range (25)
  SQLITE_CODE_RANGE = 25;
  // File opened that is not a database file (26)
  SQLITE_CODE_NOTADB = 26;
  // Notifications from sqlite3_log() (27)
  SQLITE_CODE_NOTICE = 27;
  // Warnings from sqlite3_log() (28)
  SQLITE_CODE_WARNING = 28;
  // sqlite3_step() has another row ready (100)
  SQLITE_CODE_ROW = 100;
  // sqlite3_step() has finished executing (101)
  SQLITE_CODE_DONE = 101;
}

/**
 * QueryType hints at the intent of the query, allowing the proxy to route
 * requests to the appropriate connection (e.g., read-only replicas vs WAL
 * writers).
 */
enum QueryType {
  // Default behavior (typically treats as a write or checks leader).
  QUERY_TYPE_UNSPECIFIED = 0;
  // Routes to Read-Only connection/replica.
  QUERY_TYPE_READ = 1;
  // Routes to Read-Write connection/WAL.
  QUERY_TYPE_WRITE = 2;
}

/**
 * TransactionMode defines the locking behavior for the start of a transaction.
 * Choosing the right mode is crucial for SQLite to prevent "Database Locked"
 * errors.
 */
enum TransactionMode {
  // Defaults to DEFERRED.
  TRANSACTION_MODE_UNSPECIFIED = 0;
  // Locks the DB only when the first table access occurs. Standard SQLite
  // behavior.
  TRANSACTION_MODE_DEFERRED = 1;
  // Acquires a write lock immediately. Recommended for write-heavy transactions
  // to prevent SQLITE_BUSY deadlocks.
  TRANSACTION_MODE_IMMEDIATE = 2;
  // Prevents other connections from reading while this transaction is open.
  TRANSACTION_MODE_EXCLUSIVE = 3;
}

/**
 * ColumnAffinity defines the storage class of the column.
 * This determines how the raw bytes should be interpreted at a low level.
 */
enum ColumnAffinity {
  COLUMN_AFFINITY_UNSPECIFIED = 0;
  COLUMN_AFFINITY_INTEGER = 1;
  COLUMN_AFFINITY_TEXT = 2;
  COLUMN_AFFINITY_BLOB = 3;
  COLUMN_AFFINITY_REAL = 4;
  COLUMN_AFFINITY_NUMERIC = 5;
}

/**
 * DeclaredType hints at the semantic meaning of the column.
 * This allows the client to perform automatic type coercion (e.g. String ->
 * Date).
 */
enum DeclaredType {
  DECLARED_TYPE_UNSPECIFIED = 0;

  // --- Integer Family ---
  DECLARED_TYPE_INT = 1;
  DECLARED_TYPE_INTEGER = 2;
  DECLARED_TYPE_TINYINT = 3;
  DECLARED_TYPE_SMALLINT = 4;
  DECLARED_TYPE_MEDIUMINT = 5;
  DECLARED_TYPE_BIGINT = 6;
  DECLARED_TYPE_UNSIGNED_BIG_INT = 7;
  DECLARED_TYPE_INT2 = 8;
  DECLARED_TYPE_INT8 = 9;

  // --- Character/Text Family ---
  DECLARED_TYPE_CHARACTER = 10;
  DECLARED_TYPE_VARCHAR = 11;
  DECLARED_TYPE_VARYING_CHARACTER = 12;
  DECLARED_TYPE_NCHAR = 13;
  DECLARED_TYPE_NATIVE_CHARACTER = 14;
  DECLARED_TYPE_NVARCHAR = 15;
  DECLARED_TYPE_TEXT = 16;
  DECLARED_TYPE_CLOB = 17;

  // --- Blob Family ---
  DECLARED_TYPE_BLOB = 18;

  // --- Real/Float Family ---
  DECLARED_TYPE_REAL = 19;
  DECLARED_TYPE_DOUBLE = 20;
  DECLARED_TYPE_DOUBLE_PRECISION = 21;
  DECLARED_TYPE_FLOAT = 22;

  // --- Numeric/Date/Boolean/JSON Family ---
  DECLARED_TYPE_NUMERIC = 23;
  DECLARED_TYPE_DECIMAL = 24;
  DECLARED_TYPE_BOOLEAN = 25;
  DECLARED_TYPE_DATE = 26;
  DECLARED_TYPE_DATETIME = 27;
  DECLARED_TYPE_TIMESTAMP = 28;
  DECLARED_TYPE_JSON = 29;

  // --- Specialized Types ---
  DECLARED_TYPE_UUID = 30;
  DECLARED_TYPE_TIME = 31;
  DECLARED_TYPE_YEAR = 32;
  DECLARED_TYPE_CHAR = 33;
  DECLARED_TYPE_XML = 34;
}

// -----------------------------------------------------------------------------
// Service Definition
// -----------------------------------------------------------------------------

/**
 * DatabaseService defines the API for interacting with SQLite databases.
 * It provides stateless, streaming, and transactional access patterns.
 */
// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
// buf:lint:ignore RPC_REQUEST_STANDARD_NAME
// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
service DatabaseService {
  // --- Stateless Operations ---

  /**
   * Executes a single stateless query and returns the entire result.
   * Best for point-lookups (SELECT ... WHERE id=?).
   *
   * WARNING: The server enforces a hard limit on row count (e.g., 1000) for
   * this RPC. For larger datasets, use `QueryStream`.
   */
  rpc Query(QueryRequest) returns (QueryResult);

  /**
   * Executes a stateless query and streams results.
   * Safe for large exports or reporting queries.
   * Protocol: Header -> Batch... -> Batch... -> Complete
   */
  rpc QueryStream(QueryRequest) returns (stream QueryResponse);

  // --- Stateful Operations (Model A: Bidirectional Stream) ---

  /**
   * Opens a stateful bidirectional stream for transactions.
   *
   * Flow:
   * 1. Client sends `BeginRequest`
   * 2. Client sends multiple `TransactionalQueryRequest`
   * 3. Client sends `Commit` or `Rollback`
   */
  rpc Transaction(stream TransactionRequest)
      returns (stream TransactionResponse);

  // --- Stateful Operations (Model B: Unary ID-Based) ---

  /**
   * Starts a new transaction context on the server and returns a
   * 'transaction_id'. The server holds the connection open in memory until
   * Commit, Rollback, or Timeout.
   */
  rpc BeginTransaction(BeginTransactionRequest)
      returns (BeginTransactionResponse);

  /**
   * Executes a query inside the context of an existing 'transaction_id'.
   * If the ID is invalid or timed out, returns NOT_FOUND.
   */
  rpc TransactionQuery(TransactionQueryRequest) returns (QueryResult);

  /**
   * Executes a query inside the context of an existing 'transaction_id'.
   * The server will stream the results back to the client.
   * If the ID is invalid or timed out, returns NOT_FOUND.
   */
  rpc TransactionQueryStream(TransactionQueryRequest)
      returns (stream QueryResponse);

  /**
   * Manages a savepoint (nested transaction) within an existing transaction ID.
   * If the ID is invalid or timed out, returns NOT_FOUND.
   */
  rpc TransactionSavepoint(TransactionSavepointRequest)
      returns (SavepointResponse);

  /**
   * Commits the transaction associated with the ID and releases server
   * resources.
   */
  rpc CommitTransaction(TransactionControlRequest)
      returns (TransactionControlResponse);

  /**
   * Rolls back the transaction associated with the ID and releases server
   * resources.
   */
  rpc RollbackTransaction(TransactionControlRequest)
      returns (TransactionControlResponse);

  // --- Utility Operations ---

  /**
   * Executes a predefined script of commands atomically.
   * Useful for migrations or testing where interactivity is not required.
   */
  rpc ExecuteTransaction(ExecuteTransactionRequest)
      returns (ExecuteTransactionResponse);

  // ---------------------------------------------------------------------------
  // TYPED API - Strongly-typed variants using SqlValue instead of ListValue
  // These RPCs provide better wire efficiency and eliminate the need for hints.
  // ---------------------------------------------------------------------------

  /**
   * Executes a single stateless query and returns the entire result with
   * strongly-typed values. Eliminates the need for sparse type hints.
   */
  rpc TypedQuery(TypedQueryRequest) returns (TypedQueryResult);

  /**
   * Executes a stateless query and streams strongly-typed results.
   * Protocol: TypedHeader -> TypedBatch... -> Complete
   */
  rpc TypedQueryStream(TypedQueryRequest) returns (stream TypedQueryResponse);

  // --- Typed Stateful Operations (Unary ID-Based) ---

  /**
   * Executes a typed query inside the context of an existing 'transaction_id'.
   */
  rpc TypedTransactionQuery(TypedTransactionQueryRequest)
      returns (TypedQueryResult);

  /**
   * Executes a typed query inside the context of an existing 'transaction_id'.
   * The server will stream the typed results back to the client.
   */
  rpc TypedTransactionQueryStream(TypedTransactionQueryRequest)
      returns (stream TypedQueryResponse);

  // ---------------------------------------------------------------------------
  // Developer Experience & Introspection
  // ---------------------------------------------------------------------------

  /**
   * Returns structured EXPLAIN QUERY PLAN output as a tree.
   * Helps developers understand index usage and optimization opportunities.
   */
  rpc Explain(QueryRequest) returns (ExplainResponse);

  /**
   * Typed variant of Explain using strongly-typed parameters.
   * Returns the same structured EXPLAIN QUERY PLAN output.
   */
  rpc TypedExplain(TypedQueryRequest) returns (ExplainResponse);

  /**
   * Returns a light listing of all tables in the database.
   * Useful for UI dropdowns and quick navigation.
   */
  rpc ListTables(ListTablesRequest) returns (ListTablesResponse);

  /**
   * Returns detailed schema for a single table.
   * Includes columns, indexes, foreign keys, and triggers.
   */
  rpc GetTableSchema(GetTableSchemaRequest) returns (TableSchema);

  /**
   * Returns the full database schema for exports/migrations.
   * Aggregates all tables with their complete schema information.
   */
  rpc GetDatabaseSchema(GetDatabaseSchemaRequest) returns (DatabaseSchema);

  // --- Maintenance Operations ---

  /**
   * Triggers a VACUUM command to rebuild the database file.
   * Can also perform VACUUM INTO to create a backup/copy.
   */
  rpc Vacuum(VacuumRequest) returns (VacuumResponse);

  /**
   * Manages WAL checkpoints (transferring WAL content to the main DB file).
   */
  rpc Checkpoint(CheckpointRequest) returns (CheckpointResponse);

  /**
   * Runs an integrity check on the database.
   */
  rpc IntegrityCheck(IntegrityCheckRequest) returns (IntegrityCheckResponse);
}

/**
 * AdminService handles restricted operations for user management and system
 * maintenance. Access to this service MUST be restricted to the 'admin' role.
 */
service AdminService {
  // --- User Management ---

  /**
   * Creates a new user with specific role-based access.
   * Requires admin privileges.
   */
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);

  /**
   * Permanently removes a user from the system.
   * Existing connections for this user may be terminated.
   */
  rpc DeleteUser(DeleteUserRequest) returns (DeleteUserResponse);

  /**
   * Rotates the password for a specific user.
   * The new password takes effect immediately for new connections.
   */
  rpc UpdatePassword(UpdatePasswordRequest) returns (UpdatePasswordResponse);

  // --- API Key Management ---

  /**
   * Generates a long-lived API key for a specific user.
   * The key is only returned once in the response.
   */
  rpc CreateApiKey(CreateApiKeyRequest) returns (CreateApiKeyResponse);

  /**
   * Retrieves all active API keys for a specific user.
   * Returns metadata (name, prefix) but not the full key secrets.
   */
  rpc ListApiKeys(ListApiKeysRequest) returns (ListApiKeysResponse);

  /**
   * Lists all available databases.
   */
  rpc ListDatabases(ListDatabasesRequest) returns (ListDatabasesResponse);

  /**
   * Authenticates a user and returns a session API key.
   * Requires Basic Auth for the initial request.
   */
  rpc Login(LoginRequest) returns (LoginResponse);

  /**
   * Invalidates the current session/API key.
   */
  rpc Logout(LogoutRequest) returns (LogoutResponse);

  /**
   * Revokes (deletes) a specific API key immediately.
   */
  rpc RevokeApiKey(RevokeApiKeyRequest) returns (RevokeApiKeyResponse);

  // --- Disaster Recovery ---

  // /**
  //  * Streams a binary backup of the specified database file.
  //  * The stream delivers the file in 4MB chunks.
  //  */
  // rpc BackupDatabase(BackupDatabaseRequest)
  //     returns (stream BackupDatabaseResponse);

  // /**
  //  * Restores a database from a backup stream.
  //  * This overwrites the existing database file.
  //  * Protocol: [Metadata] -> [Chunk] -> [Chunk]...
  //  */
  // rpc RestoreDatabase(stream RestoreDatabaseRequest)
  //     returns (RestoreDatabaseResponse);

  // --- Dynamic Database Management ---

  /**
   * Creates a new managed database.
   * The database file is created in the server's managed directory.
   */
  rpc CreateDatabase(CreateDatabaseRequest) returns (CreateDatabaseResponse);

  /**
   * Mounts an existing database file from the filesystem.
   * This database is marked as "unmanaged" (cannot be deleted via API).
   */
  // buf:lint:ignore RPC_REQUEST_STANDARD_NAME
  rpc MountDatabase(DatabaseConfig) returns (MountDatabaseResponse);

  /**
   * Unmounts a database, removing it from the active server.
   * The file is NOT deleted.
   */
  rpc UnMountDatabase(UnMountDatabaseRequest) returns (UnMountDatabaseResponse);

  /**
   * Deletes a database securely.
   * - Managed DBs: Deleted from disk and metadata.
   * - Mounted DBs: Returns error (protects external files).
   */
  rpc DeleteDatabase(DeleteDatabaseRequest) returns (DeleteDatabaseResponse);
}

// -----------------------------------------------------------------------------
// Core Request Messages
// -----------------------------------------------------------------------------

// --- Maintenance Messages ---

message VacuumRequest {
  string database = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];
  // Optional: If set, performs VACUUM INTO 'into_file'.
  // Relative/Absolute path handling depends on server configuration.
  optional string into_file = 2;
}

message VacuumResponse {
  bool success = 1;
  string message = 2;
}

enum CheckpointMode {
  CHECKPOINT_MODE_UNSPECIFIED = 0;
  CHECKPOINT_MODE_PASSIVE = 1;
  CHECKPOINT_MODE_FULL = 2;
  CHECKPOINT_MODE_RESTART = 3;
  CHECKPOINT_MODE_TRUNCATE = 4;
}

message CheckpointRequest {
  string database = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];
  CheckpointMode mode = 2 [ (buf.validate.field).enum.defined_only = true ];
}

message CheckpointResponse {
  bool success = 1;
  string message = 2;
  // Number of checkpoints that were busy/blocked? Or internal SQLite return
  // values. SQLite returns (busy, log, checkpointed) usually.
  // PRAGMA wal_checkpoint returns (busy, log, checkpointed)
  // Actually it returns: a single row with three integer columns:
  // 1. 0 if successful, 1 if busy. (But this is the return code of the pragma,
  // usually handled by error)
  // Wait, PRAGMA wal_checkpoint(MODE) returns (Busy, Log, Checkpointed)? No.
  // It returns: (0, N, M) where N is number of pages in WAL, M is number of
  // pages checkpointed.
  // Let's settle on:
  int64 busy_checkpoints = 3; // usually 0 or 1
  int64 log_checkpoints = 4;
  int64 checkpointed_pages = 5;
}

message IntegrityCheckRequest {
  string database = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];
  // Optional max errors to report. Defaults to 100 if not set.
  optional int32 max_errors = 2;
}

message IntegrityCheckResponse {
  bool success = 1;
  string message = 2;
  repeated string errors = 3;
}

// -----------------------------------------------------------------------------
// Admin Messages
// -----------------------------------------------------------------------------

/**
 * Role defines the permission level for a user.
 */
enum Role {
  ROLE_UNSPECIFIED = 0;
  // Full access to everything.
  ROLE_ADMIN = 1;
  // Can Read and Write data, but cannot manage users/config.
  ROLE_READ_WRITE = 2;
  // Can only Read data.
  ROLE_READ_ONLY = 3;
}

/**
 * Request to create a new database user.
 */
message CreateUserRequest {
  string username = 1
      [ (buf.validate.field).string =
            {min_len : 3, max_len : 64, pattern : "^[a-zA-Z0-9_.-]+$"} ];
  // Password MUST meet basic complexity requirements:
  // 1. Length between 8 and 128 chars.
  // 2. No whitespace allowed.
  // 3. Must contain at least one letter and one number.
  string password = 2 [ (buf.validate.field) = {
    string : {min_len : 8 max_len : 128 pattern : "^[^\\s]+$"},
    cel : [ {
      id : "password_complexity",
      message : "Password must contain at least one letter and one number",
      expression : "this.matches('.*[a-zA-Z].*') && this.matches('.*[0-9].*')"
    } ]
  } ];
  Role role = 3 [ (buf.validate.field).enum.defined_only = true ];
}

/**
 * Response containing details of the created user.
 */
message CreateUserResponse {
  int64 user_id = 1;
  google.protobuf.Timestamp created_at = 2;
}

/**
 * Request to delete an existing user.
 */
message DeleteUserRequest {
  string username = 1
      [ (buf.validate.field).string = {min_len : 1, max_len : 64} ];
}

/**
 * Response indicating the success of the user deletion.
 */
message DeleteUserResponse { bool success = 1; }

/**
 * Request to update a user's password.
 */
message UpdatePasswordRequest {
  string username = 1
      [ (buf.validate.field).string = {min_len : 1, max_len : 64} ];
  string new_password = 2 [ (buf.validate.field) = {
    string : {min_len : 8 max_len : 128 pattern : "^[^\\s]+$"},
    cel : [ {
      id : "password_complexity",
      message : "Password must contain at least one letter and one number",
      expression : "this.matches('.*[a-zA-Z].*') && this.matches('.*[0-9].*')"
    } ]
  } ];
}

/**
 * Response indicating the success of the password update.
 */
message UpdatePasswordResponse { bool success = 1; }

/**
 * Request to generate a new API key for a user.
 */
message CreateApiKeyRequest {
  int64 user_id = 1 [ (buf.validate.field).int64.gt = 0 ];
  string name = 2 [ (buf.validate.field).string = {min_len : 1, max_len : 64} ];
  google.protobuf.Timestamp expires_at = 3;
}

/**
 * Response containing the generated API key.
 * WARNING: The `api_key` field is only shown once here.
 */
message CreateApiKeyResponse {
  string api_key = 1; // The raw secret key (only shown once)
  string key_id = 2;  // UUID v7
}

/**
 * Request to list active API keys for a user.
 */
message ListApiKeysRequest {
  int64 user_id = 1 [ (buf.validate.field).int64.gt = 0 ];
}

/**
 * Response containing a list of API key summaries.
 */
message ListApiKeysResponse {
  message ApiKeySummary {
    string id = 1; // UUID v7
    string name = 2;
    string prefix = 3; // First 8 chars
    google.protobuf.Timestamp created_at = 4;
  }
  repeated ApiKeySummary keys = 1;
}

/**
 * Request to list all available databases.
 */
message ListDatabasesRequest {}

/**
 * Response containing a list of database names.
 */
message ListDatabasesResponse { repeated DatabaseInfo databases = 1; }

message DatabaseInfo {
  string name = 1;
  string path = 2;
  bool is_managed = 3;
}

/**
 * Request to authenticate and create a session.
 */
message LoginRequest {
  string username = 1;
  string password = 2;
  // Optional duration for the session. Defaults to 7 days if unspecified.
  google.protobuf.Duration session_duration = 3;
}

/**
 * Response containing the session API key and user info.
 */
message LoginResponse {
  // The generated API key for the session.
  string api_key = 1;
  // When this key expires.
  google.protobuf.Timestamp expires_at = 2;
  // Information about the authenticated user.
  User user = 3;
  // The ID of the session key (used for revocation/logout). UUID v7.
  string key_id = 4;
}

message LogoutRequest {
  // The session key ID to invalidate (UUID v7).
  // Ideally, this should match the key used for authentication,
  // but for explicit correctness we require the ID.
  string key_id = 1 [ (buf.validate.field).string.uuid = true ];
}

message LogoutResponse { bool success = 1; }

/**
 * Basic user information.
 */
message User {
  int64 id = 1;
  string username = 2;
  Role role = 3;
}

/**
 * Request to revoke (delete) a specific API key.
 */
message RevokeApiKeyRequest {
  string key_id = 1 [ (buf.validate.field).string.uuid = true ];
}

/**
 * Response indicating the success of the key revocation.
 */
message RevokeApiKeyResponse { bool success = 1; }

/**
 * Request to initiate a database backup.
 */
message BackupDatabaseRequest {
  // Optional: database name to backup (if multiple DBs supported).
  // Regex allows empty string OR valid database name.
  string database = 1
      [ (buf.validate.field).string = {pattern : "^$|^[a-zA-Z0-9_-]{3,64}$"} ];
}

/**
 * A chunk of binary data from the backup stream.
 */
message BackupDatabaseResponse {
  // 4MB limit for safety chunks
  bytes chunk = 1 [ (buf.validate.field).bytes.max_len = 4194304 ];
}

/**
 * A message in the restore stream.
 * The first message must contain `database_name`.
 * Subsequent messages must contain `chunk`.
 */
message RestoreDatabaseRequest {
  oneof payload {
    option (buf.validate.oneof).required = true;

    // The name of the database to restore (sent in the first message).
    string database_name = 1
        [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];
    // A chunk of binary data to write (sent in subsequent messages).
    bytes chunk = 2
        [ (buf.validate.field).bytes = {min_len : 1, max_len : 4194304} ];
  }
}

/**
 * Response indicating the final status of the restore operation.
 */
message RestoreDatabaseResponse {
  bool success = 1;
  int64 bytes_written = 2;
}

// -----------------------------------------------------------------------------
// Dynamic Database Management Messages
// -----------------------------------------------------------------------------

message CreateDatabaseRequest {
  // Name is the logical identifier for the database.
  // Must be alphanumeric (plus _-), 3-64 chars.
  string name = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];

  // Is Encrypted indicates if the database is encrypted via sqlcipher.
  bool is_encrypted = 2;

  // Key for sql cipher.
  // If is_encrypted is true and key is empty, the default key may be used.
  string key = 3;

  // Extensions is a list of paths to shared library extensions to load.
  repeated string extensions = 4;

  // Pragmas allows passing arbitrary key-value pairs to the DSN.
  map<string, string> pragmas = 5;

  // MaxOpenConns limits the number of open physical connections.
  int32 max_open_conns = 6;

  // MaxIdleConns limits how many connections wait in the pool.
  int32 max_idle_conns = 7;

  // ConnMaxLifetimeMs sets how long a connection can be reused before closing.
  int32 conn_max_lifetime_ms = 8;
}

message CreateDatabaseResponse {
  bool success = 1;
  string message = 2;
}

message MountDatabaseResponse {
  bool success = 1;
  string message = 2;
}

message UnMountDatabaseRequest {
  string name = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];
}

message UnMountDatabaseResponse {
  bool success = 1;
  string message = 2;
}

message DeleteDatabaseRequest {
  string name = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];
}

message DeleteDatabaseResponse {
  bool success = 1;
  string message = 2;
}

/**
 * A request for the stateless `Query` and `QueryStream` RPCs.
 */
message QueryRequest {
  // Database name. Must be alphanumeric (plus _-), 3-64 chars.
  // Validated to prevent directory traversal attacks.
  string database = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];

  // SQL Statement. Max 10KB to prevent memory abuse.
  string sql = 2
      [ (buf.validate.field).string = {min_len : 1 max_len : 10240} ];

  // Optional hint to optimize connection routing (Read vs Write).
  QueryType type = 3 [ (buf.validate.field).enum.defined_only = true ];

  // Parameters definition (Positional or Named).
  Parameters parameters = 4;
}

/**
 * Encapsulates all parameter logic using a "Sparse Hinting" strategy.
 * This structure avoids overhead by only requiring types for ambiguous values.
 */
message Parameters {
  google.protobuf.ListValue positional = 1;
  google.protobuf.Struct named = 2;

  // Sparse Type Hints.
  // ONLY populate these for values that JSON/ListValue handles poorly.
  // Examples:
  // - A String "123" that must be treated as INT64 in DB -> Hint INTEGER
  // - A String "base64..." that must be decoded to bytes -> Hint BLOB
  //
  // For standard strings, bools, and small ints, NO HINT IS NEEDED.

  // Key: The 0-based index of the positional parameter.
  map<int32, ColumnAffinity> positional_hints = 3 [
    (buf.validate.field).map.keys.int32.gte = 0,
    (buf.validate.field).map.max_pairs = 1000,
    (buf.validate.field).map.values.enum.defined_only = true
  ];

  // Key: The parameter name (e.g., ":id", "@user").
  map<string, ColumnAffinity> named_hints = 4 [
    (buf.validate.field).map.keys.string.min_len = 1,
    (buf.validate.field).map.max_pairs = 1000,
    (buf.validate.field).map.values.enum.defined_only = true
  ];
}

// -----------------------------------------------------------------------------
// Unary Transaction Messages (ID-Based)
// -----------------------------------------------------------------------------

/**
 * Request to start a new ID-based transaction session.
 */
message BeginTransactionRequest {
  // Database name to lock.
  string database = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];

  // How long the server should keep this transaction alive without activity
  // before auto-rolling back. (e.g., "30s", "1m").
  // If unspecified, defaults to server configuration (usually 30s).
  google.protobuf.Duration timeout = 2;

  // The locking mode to use (DEFERRED, IMMEDIATE, EXCLUSIVE).
  TransactionMode mode = 3 [ (buf.validate.field).enum.defined_only = true ];
}

/**
 * Response containing the transaction session token.
 */
message BeginTransactionResponse {
  // The unique session token the client MUST send in subsequent
  // 'TransactionQuery' calls.
  string transaction_id = 1;

  // When this transaction will expire (Unix MS) if no further commands are
  // sent. Clients can use this to anticipate timeouts.
  google.protobuf.Timestamp expires_at = 2;
}

/**
 * Request to execute a query within an existing transaction session.
 */
message TransactionQueryRequest {
  // The token received from BeginTransaction.
  // Note: No database name needed; the ID implies the database context.
  string transaction_id = 1
      [ (buf.validate.field).string = {min_len : 1, max_len : 128} ];

  // The SQL statement to execute.
  string sql = 2
      [ (buf.validate.field).string = {min_len : 1 max_len : 10240} ];

  // Parameters for the query.
  Parameters parameters = 3;
}

/**
 * Request to perform a savepoint operation using a transaction ID.
 */
message TransactionSavepointRequest {
  // The token received from BeginTransaction.
  string transaction_id = 1
      [ (buf.validate.field).string = {min_len : 1, max_len : 128} ];

  // The savepoint action and name.
  SavepointRequest savepoint = 2 [ (buf.validate.field).required = true ];
}

/**
 * Request to Commit or Rollback a transaction session.
 */
message TransactionControlRequest {
  // The session token to finalize.
  string transaction_id = 1
      [ (buf.validate.field).string = {min_len : 1, max_len : 128} ];
}

/**
 * Response indicating success of the control operation.
 */
message TransactionControlResponse {
  // True if the Commit/Rollback was successful.
  // False usually indicates the transaction ID was not found (already
  // expired/closed).
  bool success = 1;
}

// -----------------------------------------------------------------------------
// Streaming Transaction Messages
// -----------------------------------------------------------------------------

/**
 * The envelope message for a single command within a bidirectional stream.
 * It uses a `oneof` to enforce that only one action is taken per message.
 */
message TransactionRequest {
  oneof command {
    option (buf.validate.oneof).required = true;

    // Starts the transaction
    BeginRequest begin = 1;

    // --- Untyped Query API (uses ListValue) ---

    // Executes a query and expects the result buffered in a single response.
    // Use this for small lookups or DML (INSERT/UPDATE).
    TransactionalQueryRequest query = 2;

    // Executes a query and expects the result to be streamed back in multiple
    // TransactionResponse messages (Header -> Batch... -> Complete).
    // Use this for large SELECTs within a transaction.
    TransactionalQueryRequest query_stream = 3;

    // --- Typed Query API (uses SqlValue - no hints needed) ---

    // Executes a typed query and expects the result buffered in a single
    // response.
    TypedTransactionalQueryRequest typed_query = 4;

    // Executes a typed query and expects the result to be streamed back.
    TypedTransactionalQueryRequest typed_query_stream = 5;

    // Manages a sub-transaction (Nested Transaction) using SQLite SAVEPOINTS.
    SavepointRequest savepoint = 7;

    // Finalizes the transaction
    google.protobuf.Empty commit = 8;
    google.protobuf.Empty rollback = 9;
  }
}

/**
 * Initiates a new transaction context in the stream.
 * This MUST be the first message sent.
 */
message BeginRequest {
  // Database name. Must match the standard naming pattern.
  // This locks the connection to this specific database for the duration of the
  // stream.
  string database = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];

  // The locking mode. Defaults to DEFERRED if unspecified.
  // Use IMMEDIATE or EXCLUSIVE for write-heavy transactions to avoid
  // busy-loops.
  TransactionMode mode = 2 [ (buf.validate.field).enum.defined_only = true ];
}

/**
 * A query executed within an active transaction context.
 * Unlike `QueryRequest`, this does not specify a database name as the context
 * is already established.
 */
message TransactionalQueryRequest {
  // SQL Statement. Max 10KB.
  string sql = 1
      [ (buf.validate.field).string = {min_len : 1 max_len : 10240} ];

  // Parameters definition.
  Parameters parameters = 2;
}

/**
 * Defines the action to take on a Savepoint (Nested Transaction).
 */
enum SavepointAction {
  SAVEPOINT_ACTION_UNSPECIFIED = 0;
  // Creates a new savepoint: "SAVEPOINT <name>"
  SAVEPOINT_ACTION_CREATE = 1;
  // Commits/Removes a savepoint: "RELEASE <name>"
  SAVEPOINT_ACTION_RELEASE = 2;
  // Reverts to a savepoint: "ROLLBACK TO <name>"
  SAVEPOINT_ACTION_ROLLBACK = 3;
}

/**
 * Request to manage a named checkpoint within an active transaction.
 */
message SavepointRequest {
  // The name of the savepoint. Must be alphanumeric (plus _-).
  string name = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{1,64}$"} ];

  // The operation to perform on this savepoint.
  SavepointAction action = 2 [ (buf.validate.field).enum.defined_only = true ];
}

/**
 * A container for a sequence of transaction steps to be executed atomically via
 * Unary RPC. This is meant for simple, linear scripts (like migrations) where
 * client-side interactivity isn't needed.
 */
message ExecuteTransactionRequest {
  // ATOMIC SCRIPT CONSTRAINTS:
  // 1. Must contain between 2 and 100 requests (Begin + at least 1 action +
  // Commit).
  // 2. The first command MUST be a 'Begin' command.
  // 3. The last command MUST be either 'Commit' or 'Rollback' to ensure no
  // dangling locks.
  repeated TransactionRequest requests = 1 [
    (buf.validate.field).repeated.min_items = 2,
    (buf.validate.field).repeated.max_items = 100,
    (buf.validate.field).cel = {
      id : "transaction.sequence_start"
      message : "The first command in an ExecuteTransaction script must be "
                "'begin'"
      expression : "has(this[0].begin)"
    },
    (buf.validate.field).cel = {
      id : "transaction.sequence_end"
      message : "The script must explicitly end with 'commit' or 'rollback'"
      expression : "has(this[this.size() - 1].commit) || has(this[this.size() "
                   "- 1].rollback)"
    }
  ];
}

// -----------------------------------------------------------------------------
// Response Messages
// -----------------------------------------------------------------------------

/**
 * The response for Unary RPCs (`Query`, `TransactionQuery`).
 * This message holds the entire result set in memory.
 */
message QueryResult {
  // The result payload. Either a SELECT result or DML result.
  oneof result {
    SelectResult select = 1;
    DMLResult dml = 2;
  }
  // Performance statistics for the execution.
  ExecutionStats stats = 3;
}

/**
 * The response envelope for streaming RPCs (`QueryStream` and `Transaction`).
 * The stream will typically send: [Header] -> [Batch]* -> [Complete].
 */
message QueryResponse {
  oneof response {
    // Sent once at the start of a result set to define columns.
    QueryResultHeader header = 1;
    // Sent repeatedly containing chunks of rows.
    QueryResultRowBatch batch = 2;
    // Sent once when the query successfully finishes.
    QueryComplete complete = 3;
    // Sent if the query was an INSERT/UPDATE/DELETE.
    DMLResult dml = 4;
    // Sent if an error occurs mid-stream.
    ErrorResponse error = 5;
  }
}

/**
 * The response envelope for the `Transaction` RPC.
 * Mirrors QueryResponse but adds Transaction-specific lifecycle messages.
 */
message TransactionResponse {
  oneof response {
    // Starts the transaction
    BeginResponse begin = 1;

    // --- Untyped Query Result Models (uses ListValue) ---

    // Returned exactly once in response to a 'query' request.
    // Contains the full rows and column metadata in one message.
    QueryResult query_result = 2;

    // Returned multiple times in response to a 'query_stream' request.
    // Follows the streaming protocol (Header -> Batch... -> Complete).
    QueryResponse stream_result = 3;

    // --- Typed Query Result Models (uses SqlValue) ---

    // Returned exactly once in response to a 'typed_query' request.
    TypedQueryResult typed_query_result = 4;

    // Returned multiple times in response to a 'typed_query_stream' request.
    TypedQueryResponse typed_stream_result = 5;

    // Response for a savepoint operation.
    SavepointResponse savepoint = 7;

    // Finalizes the transaction
    CommitResponse commit = 8;
    RollbackResponse rollback = 9;

    // --- System Errors ---
    // Used for failures in Begin/Commit/Rollback or protocol violations.
    ErrorResponse error = 10;
  }
}

/**
 * Response indicating the outcome of a savepoint-related command.
 *
 * This message is returned within the TransactionResponse envelope in
 * response to a SavepointRequest.
 */
message SavepointResponse {
  // Indicates if the SQLite savepoint command (SAVEPOINT, RELEASE, or ROLLBACK
  // TO) was executed successfully.
  bool success = 1;

  // The name of the savepoint that was targeted.
  // Echoed back to allow the client to track multiple nested checkpoints.
  string name = 2;

  // The action that was performed.
  // Echoed back to help the client correlate the response with their command.
  SavepointAction action = 3;
}

/**
 * The response for the unary `ExecuteTransaction` RPC.
 */
message ExecuteTransactionResponse {
  // A list of responses corresponding 1-to-1 with the requests in the input
  // script. Allows the client to verify which step succeeded or failed.
  repeated TransactionResponse responses = 1;
}

// -----------------------------------------------------------------------------
// Shared Data Types
// -----------------------------------------------------------------------------

/**
 * Represents the full result set of a SELECT query (used in Unary RPC).
 */
message SelectResult {
  // The names of the columns returned by the query.
  repeated string columns = 1;
  // The resolved column types mapped from SQLite declarations.
  repeated ColumnAffinity column_affinities = 2;
  repeated DeclaredType column_declared_types = 3;
  repeated string column_raw_types = 4;
  // All rows buffered in memory.
  repeated google.protobuf.ListValue rows = 5;
}

/**
 * Represents the result of a Data Modification Language query (INSERT, UPDATE,
 * DELETE).
 */
message DMLResult {
  // The number of rows modified by the query.
  int64 rows_affected = 1;
  // The ROWID of the last inserted row (if applicable).
  int64 last_insert_id = 2;
}

/**
 * Metadata about the columns in a result set (Streaming).
 * Sent as the first message in a read stream.
 */
message QueryResultHeader {
  // The names of the columns.
  repeated string columns = 1;
  // The resolved column types mapped from SQLite declarations.
  repeated ColumnAffinity column_affinities = 2;
  repeated DeclaredType column_declared_types = 3;
  repeated string column_raw_types = 4;
}

/**
 * A batch of rows in a streaming response.
 * Used to chunk large result sets to avoid memory spikes.
 */
message QueryResultRowBatch {
  // A list of rows, where each row is a ListValue.
  repeated google.protobuf.ListValue rows = 1;
}

/**
 * Signals the successful completion of a read query stream.
 */
message QueryComplete {
  // Final execution statistics.
  ExecutionStats stats = 1;
}

/**
 * Performance metrics for a query execution.
 * Useful for profiling and monitoring.
 */
message ExecutionStats {
  // Total execution time in milliseconds.
  double duration_ms = 1;
  // Number of rows read from the database.
  int64 rows_read = 2;
  // Number of rows written/modified.
  int64 rows_written = 3;
}

/** Response indicating a transaction successfully started. */
message BeginResponse {
  bool success = 1;
  // Optional internal transaction identifier (useful for debugging).
  // Trace Id for the whole transaction
  string transaction_id = 2 [ (buf.validate.field).string = {uuid : true} ];
}

/** Response indicating a transaction successfully committed. */
message CommitResponse { bool success = 1; }

/** Response indicating a transaction successfully rolled back. */
message RollbackResponse { bool success = 1; }

/**
 * Standard error response attached to failures.
 * This is sent as a stream message (Streaming) or Error Detail (Unary).
 */
message ErrorResponse {
  // Human-readable error message.
  string message = 1;
  // The SQL that caused the error (if available/safe to return).
  string failed_sql = 2;
  // The precise SQLite error code for programmatic handling.
  // Reference: https://www.sqlite.org/rescode.html
  SqliteCode sqlite_error_code = 3;
}

// =============================================================================
// TYPED API MESSAGES
// =============================================================================
// These messages provide strongly-typed value representations that eliminate
// the need for sparse type hints and provide better wire efficiency than
// google.protobuf.ListValue.

/**
 * Represents a single SQL value with explicit type information.
 * This replaces the dynamic typing of google.protobuf.Value with
 * SQLite-specific semantics.
 */
message SqlValue {
  oneof value {
    // SQLite INTEGER (64-bit signed). Maps to int64.
    int64 integer_value = 1;
    // SQLite REAL (64-bit IEEE floating point). Maps to double.
    double real_value = 2;
    // SQLite TEXT (UTF-8 string). Maps to string.
    string text_value = 3;
    // SQLite BLOB (arbitrary bytes). Maps to bytes directly (no base64).
    bytes blob_value = 4;
    // SQLite NULL. True if this value is NULL.
    bool null_value = 5;
  }
}

/**
 * Represents a single row of SQL values.
 * Each value corresponds positionally to a column in the result header.
 */
message SqlRow { repeated SqlValue values = 1; }

// -----------------------------------------------------------------------------
// Typed Request Messages
// -----------------------------------------------------------------------------

/**
 * Typed parameters for query binding.
 * Unlike Parameters, these use SqlValue for explicit typing (no hints needed).
 */
message TypedParameters {
  // Positional parameters (bound by index: ?1, ?2, ...).
  repeated SqlValue positional = 1
      [ (buf.validate.field).repeated.max_items = 1000 ];

  // Named parameters (bound by name: :id, @user, $name).
  // Key is the parameter name WITHOUT the prefix (e.g., "id" for ":id").
  map<string, SqlValue> named = 2 [
    (buf.validate.field).map.keys.string.min_len = 1,
    (buf.validate.field).map.max_pairs = 1000
  ];
}

/**
 * A request for the stateless `TypedQuery` and `TypedQueryStream` RPCs.
 */
message TypedQueryRequest {
  // Database name. Must be alphanumeric (plus _-), 3-64 chars.
  string database = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];

  // SQL Statement. Max 10KB.
  string sql = 2
      [ (buf.validate.field).string = {min_len : 1 max_len : 10240} ];

  // Optional hint to optimize connection routing.
  QueryType type = 3 [ (buf.validate.field).enum.defined_only = true ];

  // Typed parameters (no hints required).
  TypedParameters parameters = 4;
}

/**
 * Request to execute a typed query within an existing transaction session.
 */
message TypedTransactionQueryRequest {
  // The token received from BeginTransaction.
  string transaction_id = 1
      [ (buf.validate.field).string = {min_len : 1, max_len : 128} ];

  // The SQL statement to execute.
  string sql = 2
      [ (buf.validate.field).string = {min_len : 1 max_len : 10240} ];

  // Typed parameters for the query.
  TypedParameters parameters = 3;
}

/**
 * A typed query executed within an active transaction context (streaming).
 */
message TypedTransactionalQueryRequest {
  // SQL Statement. Max 10KB.
  string sql = 1
      [ (buf.validate.field).string = {min_len : 1 max_len : 10240} ];

  // Typed parameters definition.
  TypedParameters parameters = 2;
}

// -----------------------------------------------------------------------------
// Typed Response Messages
// -----------------------------------------------------------------------------

/**
 * Represents the full result set of a SELECT query with typed values.
 */
message TypedSelectResult {
  // The names of the columns returned by the query.
  repeated string columns = 1;
  // The resolved column affinities.
  repeated ColumnAffinity column_affinities = 2;
  // The declared types as specified in the schema.
  repeated DeclaredType column_declared_types = 3;
  // The raw type strings from the schema.
  repeated string column_raw_types = 4;
  // All rows with strongly-typed values.
  repeated SqlRow rows = 5;
}

/**
 * The response for typed unary RPCs (`TypedQuery`, `TypedTransactionQuery`).
 */
message TypedQueryResult {
  oneof result {
    TypedSelectResult select = 1;
    DMLResult dml = 2;
  }
  ExecutionStats stats = 3;
}

/**
 * Metadata about the columns in a typed result set (Streaming).
 * Sent as the first message in a typed read stream.
 */
message TypedQueryResultHeader {
  repeated string columns = 1;
  repeated ColumnAffinity column_affinities = 2;
  repeated DeclaredType column_declared_types = 3;
  repeated string column_raw_types = 4;
}

/**
 * A batch of typed rows in a streaming response.
 */
message TypedQueryResultRowBatch { repeated SqlRow rows = 1; }

/**
 * The response envelope for typed streaming RPCs.
 * Stream protocol: [TypedHeader] -> [TypedBatch]* -> [Complete].
 */
message TypedQueryResponse {
  oneof response {
    // Sent once at the start to define columns.
    TypedQueryResultHeader header = 1;
    // Sent repeatedly containing chunks of typed rows.
    TypedQueryResultRowBatch batch = 2;
    // Sent once when the query successfully finishes.
    QueryComplete complete = 3;
    // Sent if the query was an INSERT/UPDATE/DELETE.
    DMLResult dml = 4;
    // Sent if an error occurs mid-stream.
    ErrorResponse error = 5;
  }
}

// -----------------------------------------------------------------------------
// Database Configuration
// -----------------------------------------------------------------------------

/**
 * DatabaseConfig defines the configuration for a single database.
 * Used for both static configuration (config.json) and dynamic management.
 */
message DatabaseConfig {
  // Name is the logical identifier for the database.
  // Must be alphanumeric (plus _-), 3-64 chars.
  string name = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];

  // DBPath is the file system path to the SQLite database file.
  string db_path = 2 [ (buf.validate.field).string.min_len = 1 ];

  // Is Encrypted indicates if the database is encrypted via sqlcipher.
  bool is_encrypted = 3;

  // Key for sql cipher.
  // If is_encrypted is true and key is empty, the default key may be used.
  string key = 4;

  // ReadOnly opens the database in read-only mode (mode=ro).
  bool read_only = 5;

  // Extensions is a list of paths to shared library extensions to load.
  repeated string extensions = 6;

  // Pragmas allows passing arbitrary key-value pairs to the DSN.
  map<string, string> pragmas = 7;

  // MaxOpenConns limits the number of open physical connections.
  int32 max_open_conns = 8;

  // MaxIdleConns limits how many connections wait in the pool.
  int32 max_idle_conns = 9;

  // ConnMaxLifetimeMs sets how long a connection can be reused before closing.
  int32 conn_max_lifetime_ms = 10;
}

// =============================================================================
// DEVELOPER EXPERIENCE & INTROSPECTION MESSAGES
// =============================================================================

// -----------------------------------------------------------------------------
// Explain Query Plan
// -----------------------------------------------------------------------------

/**
 * Response containing the structured EXPLAIN QUERY PLAN output.
 * The nodes form a tree via the parent_id references.
 */
message ExplainResponse {
  // All nodes in the query plan, use parent_id to reconstruct tree structure.
  repeated QueryPlanNode nodes = 1;
}

/**
 * A single node in the EXPLAIN QUERY PLAN tree.
 * Maps directly to SQLite's output: id, parent, notused, detail.
 */
message QueryPlanNode {
  // Unique identifier for this node within the query plan.
  int32 id = 1;
  // Parent node ID (0 for root nodes).
  int32 parent_id = 2;
  // The operation description (e.g., "SCAN users", "SEARCH users USING INDEX").
  string detail = 3;
}

// -----------------------------------------------------------------------------
// Schema Introspection
// -----------------------------------------------------------------------------

/**
 * Request to list all tables in a database.
 */
message ListTablesRequest {
  string database = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];
}

/**
 * Response containing a list of table names.
 */
message ListTablesResponse { repeated string table_names = 1; }

/**
 * Request to get detailed schema for a single table.
 */
message GetTableSchemaRequest {
  string database = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];
  string table_name = 2
      [ (buf.validate.field).string = {min_len : 1, max_len : 256} ];
}

/**
 * Request to get the complete database schema.
 */
message GetDatabaseSchemaRequest {
  string database = 1
      [ (buf.validate.field).string = {pattern : "^[a-zA-Z0-9_-]{3,64}$"} ];
}

/**
 * Complete schema information for a single table.
 */
message TableSchema {
  // Table name.
  string name = 1;
  // Original CREATE TABLE SQL statement.
  string sql = 2;
  // Column definitions.
  repeated ColumnSchema columns = 3;
  // Indexes on this table.
  repeated IndexSchema indexes = 4;
  // Foreign key constraints.
  repeated ForeignKeySchema foreign_keys = 5;
  // Triggers associated with this table.
  repeated TriggerSchema triggers = 6;
}

/**
 * Schema information for a single column.
 * Derived from PRAGMA table_info().
 */
message ColumnSchema {
  // Column name.
  string name = 1;
  // Declared type (e.g., "INTEGER", "TEXT", "VARCHAR(255)").
  string type = 2;
  // True if column has NOT NULL constraint.
  bool not_null = 3;
  // Default value expression (may be empty).
  string default_value = 4;
  // True if column is part of primary key.
  bool primary_key = 5;
}

/**
 * Schema information for a single index.
 * Derived from PRAGMA index_list() and index_info().
 */
message IndexSchema {
  // Index name.
  string name = 1;
  // True if this is a UNIQUE index.
  bool unique = 2;
  // Column names in the index (in order).
  repeated string columns = 3;
  // Original CREATE INDEX SQL statement (empty for auto-created indexes).
  string sql = 4;
}

/**
 * Schema information for a foreign key constraint.
 * Derived from PRAGMA foreign_key_list().
 */
message ForeignKeySchema {
  // Foreign key ID (multiple columns share same ID for composite FKs).
  int32 id = 1;
  // Referenced (parent) table name.
  string table = 2;
  // Column in this (child) table.
  string from_column = 3;
  // Column in the referenced (parent) table.
  string to_column = 4;
  // ON UPDATE action (e.g., "CASCADE", "NO ACTION").
  string on_update = 5;
  // ON DELETE action (e.g., "CASCADE", "SET NULL").
  string on_delete = 6;
}

/**
 * Schema information for a trigger.
 * Derived from sqlite_schema WHERE type='trigger'.
 */
message TriggerSchema {
  // Trigger name.
  string name = 1;
  // Original CREATE TRIGGER SQL statement.
  string sql = 2;
}

/**
 * Complete schema for an entire database.
 * Contains all tables with their complete schema information.
 */
message DatabaseSchema {
  // All tables in the database with full schema details.
  repeated TableSchema tables = 1;
}
