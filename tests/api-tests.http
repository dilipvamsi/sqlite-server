@hostname = localhost
@port = 50173
@host = http://{{hostname}}:{{port}}
@dbName = loadtest
# Use "loadtest-cipher" if you ran the go code with -cipher

# ==============================================================================
# 1. UNARY QUERY (Simple Select)
# ==============================================================================
# Fetch a single user by ID.
# This tests the basic "Query" endpoint used for point-lookups.
POST {{host}}/db.v1.DatabaseService/Query
Content-Type: application/json
X-Request-Id: {{ $guid }}

{
  "database": "{{dbName}}",
  "sql": "SELECT id, name, email FROM users WHERE id = 1"
}

###

# ==============================================================================
# 2. PARAMETERIZED QUERY (Positional)
# ==============================================================================
# Fetch users using '?' placeholders.
# JSON array values map directly to SQL parameters.
POST {{host}}/db.v1.DatabaseService/Query
Content-Type: application/json

{
  "database": "{{dbName}}",
  "sql": "SELECT name, country, age FROM users WHERE country = ? AND age > ? LIMIT 5",
  "parameters": {
    "positional": [
      "Canada",
      25
    ]
  }
}

###

# ==============================================================================
# 3. PARAMETERIZED QUERY (Named)
# ==============================================================================
# Fetch users using ':name' placeholders.
POST {{host}}/db.v1.DatabaseService/Query
Content-Type: application/json

{
  "database": "{{dbName}}",
  "sql": "SELECT * FROM users WHERE email = :email",
  "parameters": {
    "named": {
      ":email": "user500@example.com"
    }
  }
}

###

# ==============================================================================
# 4. STREAMING QUERY (Fetch Large Dataset)
# ==============================================================================
# Fetches a larger chunk of rows using the Streaming endpoint.
# The server should respond with multiple JSON objects (Header -> Batch -> Batch -> Complete).
POST {{host}}/db.v1.DatabaseService/QueryStream
Content-Type: application/json

{
  "database": "{{dbName}}",
  "sql": "SELECT id, name, country FROM users WHERE country = 'USA' LIMIT 100"
}

###

# ==============================================================================
# 5. DML (Insert with Sparse Hints)
# ==============================================================================
# Insert a new record.
# Demonstrates "Sparse Hints" (forcing age to be INTEGER, though JSON infers float).
# 2 = COLUMN_TYPE_INTEGER
POST {{host}}/db.v1.DatabaseService/Query
Content-Type: application/json

{
  "database": "{{dbName}}",
  "sql": "INSERT INTO users (name, email, country, age) VALUES (?, ?, ?, ?)",
  "parameters": {
    "positional": [
      "HTTP Client User",
      "http@test.com",
      "Internet",
      99
    ],
    "positional_hints": {
      "3": "COLUMN_TYPE_INTEGER"
    }
  }
}

###

# ==============================================================================
# 6. ATOMIC TRANSACTION SCRIPT (ExecuteTransaction)
# ==============================================================================
# Runs a sequence of commands atomically:
# 1. BEGIN
# 2. INSERT a new user
# 3. SELECT the ID of that user
# 4. COMMIT
POST {{host}}/db.v1.DatabaseService/ExecuteTransaction
Content-Type: application/json

{
  "requests": [
    {
      "begin": {
        "database": "{{dbName}}"
      }
    },
    {
      "query": {
        "sql": "INSERT INTO users (name, email, country, age) VALUES ('Transaction User', 'trans@test.com', 'France', 30)"
      }
    },
    {
      "query": {
        "sql": "SELECT last_insert_rowid() as new_id"
      }
    },
    {
      "commit": {}
    }
  ]
}

###

# ==============================================================================
# 7. ERROR HANDLING (Invalid SQL)
# ==============================================================================
# Tests how the server returns SQL errors (e.g., table does not exist).
POST {{host}}/db.v1.DatabaseService/Query
Content-Type: application/json

{
  "database": "{{dbName}}",
  "sql": "SELECT * FROM non_existent_table"
}
